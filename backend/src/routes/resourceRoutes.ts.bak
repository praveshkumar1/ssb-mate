import { Router, Request, Response } from 'express';
import { body, validationResult } from 'express-validator';
import { v4 as uuidv4 } from 'uuid';
import { getDatabase } from '../database/connection';
import { logger } from '../utils/logger';
import { authenticate, authorize, AuthenticatedRequest } from '../middleware/auth';
import { ResourceCreate, ResourceCategory, UserRole } from '../types/enhanced';

const router = Router();

// Validation rules
const createResourceValidation = [
  body('title').trim().isLength({ min: 3 }).withMessage('Title must be at least 3 characters'),
  body('description').optional().isLength({ max: 500 }).withMessage('Description must be less than 500 characters'),
  body('content').trim().isLength({ min: 10 }).withMessage('Content must be at least 10 characters'),
  body('category').isIn(Object.values(ResourceCategory)).withMessage('Invalid category'),
  body('tags').optional().isArray().withMessage('Tags must be an array'),
  body('isPublic').optional().isBoolean().withMessage('isPublic must be a boolean')
];

// POST /api/resources - Create a new resource (mentors only)
router.post('/', authenticate, authorize([UserRole.MENTOR, UserRole.ADMIN]), createResourceValidation, async (req: AuthenticatedRequest, res: Response): Promise<void> => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      res.status(400).json({
        success: false,
        error: 'Validation failed',
        details: errors.array(),
        timestamp: new Date().toISOString()
      });
      return;
    }

    if (!req.user) {
      res.status(401).json({
        success: false,
        error: 'User not authenticated',
        timestamp: new Date().toISOString()
      });
      return;
    }

    const { title, description, content, category, tags = [], isPublic = true }: ResourceCreate = req.body;
    const db = getDatabase();

    // Create resource
    const resourceId = uuidv4();
    const now = new Date().toISOString();

    const resourceData = {
      id: resourceId,
      title,
      description: description || null,
      content,
      category,
      author_id: req.user.id,
      tags: JSON.stringify(tags),
      is_public: isPublic,
      created_at: now,
      updated_at: now
    };

    await db('resources').insert(resourceData);

    const resource = {
      id: resourceId,
      title,
      description,
      content,
      category,
      authorId: req.user.id,
      tags,
      isPublic,
      createdAt: now,
      updatedAt: now
    };

    logger.info(`Resource created: ${resourceId} by user ${req.user.email}`);
    res.status(201).json({
      success: true,
      data: resource,
      message: 'Resource created successfully',
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    logger.error('Error creating resource:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to create resource',
      timestamp: new Date().toISOString()
    });
  }
});

// GET /api/resources - Get all public resources
router.get('/', async (req: Request, res: Response): Promise<void> => {
  try {
    const { page = 1, limit = 10, category, search } = req.query;
    const db = getDatabase();
    const offset = (Number(page) - 1) * Number(limit);

    let query = db('resources')
      .join('users', 'resources.author_id', 'users.id')
      .where('resources.is_public', true)
      .select(
        'resources.*',
        'users.full_name as author_name'
      );

    if (category) {
      query = query.where('resources.category', category);
    }

    if (search) {
      query = query.where(function() {
        this.whereRaw('LOWER(resources.title) LIKE ?', [`%${String(search).toLowerCase()}%`])
            .orWhereRaw('LOWER(resources.description) LIKE ?', [`%${String(search).toLowerCase()}%`]);
      });
    }

    const resources = await query
      .limit(Number(limit))
      .offset(offset)
      .orderBy('resources.created_at', 'desc');

    const totalCount = await db('resources')
      .where('is_public', true)
      .modify(function(queryBuilder) {
        if (category) {
          queryBuilder.where('category', category);
        }
        if (search) {
          queryBuilder.where(function() {
            this.whereRaw('LOWER(title) LIKE ?', [`%${String(search).toLowerCase()}%`])
                .orWhereRaw('LOWER(description) LIKE ?', [`%${String(search).toLowerCase()}%`]);
          });
        }
      })
      .count('* as count')
      .first();

    const total = Number(totalCount?.count || 0);
    const totalPages = Math.ceil(total / Number(limit));

    const resourceResponse = resources.map(resource => ({
      id: resource.id,
      title: resource.title,
      description: resource.description,
      content: resource.content,
      category: resource.category,
      authorId: resource.author_id,
      authorName: resource.author_name,
      tags: JSON.parse(resource.tags || '[]'),
      isPublic: resource.is_public,
      downloadUrl: resource.download_url,
      fileType: resource.file_type,
      createdAt: resource.created_at,
      updatedAt: resource.updated_at
    }));

    res.json({
      success: true,
      data: resourceResponse,
      pagination: {
        page: Number(page),
        limit: Number(limit),
        total,
        totalPages,
        hasNext: Number(page) < totalPages,
        hasPrevious: Number(page) > 1
      },
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    logger.error('Error getting resources:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to get resources',
      timestamp: new Date().toISOString()
    });
  }
});

// GET /api/resources/my - Get user's resources
router.get('/my', authenticate, async (req: AuthenticatedRequest, res: Response): Promise<void> => {
  try {
    if (!req.user) {
      res.status(401).json({
        success: false,
        error: 'User not authenticated',
        timestamp: new Date().toISOString()
      });
      return;
    }

    const { page = 1, limit = 10 } = req.query;
    const db = getDatabase();
    const offset = (Number(page) - 1) * Number(limit);

    const resources = await db('resources')
      .where('author_id', req.user.id)
      .select('*')
      .limit(Number(limit))
      .offset(offset)
      .orderBy('created_at', 'desc');

    const totalCount = await db('resources')
      .where('author_id', req.user.id)
      .count('* as count')
      .first();

    const total = Number(totalCount?.count || 0);
    const totalPages = Math.ceil(total / Number(limit));

    const resourceResponse = resources.map(resource => ({
      id: resource.id,
      title: resource.title,
      description: resource.description,
      content: resource.content,
      category: resource.category,
      authorId: resource.author_id,
      tags: JSON.parse(resource.tags || '[]'),
      isPublic: resource.is_public,
      downloadUrl: resource.download_url,
      fileType: resource.file_type,
      createdAt: resource.created_at,
      updatedAt: resource.updated_at
    }));

    res.json({
      success: true,
      data: resourceResponse,
      pagination: {
        page: Number(page),
        limit: Number(limit),
        total,
        totalPages,
        hasNext: Number(page) < totalPages,
        hasPrevious: Number(page) > 1
      },
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    logger.error('Error getting user resources:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to get resources',
      timestamp: new Date().toISOString()
    });
  }
});

// GET /api/resources/:id - Get resource by ID
router.get('/:id', async (req: Request, res: Response): Promise<void> => {
  try {
    const { id } = req.params;
    const db = getDatabase();

    const resource = await db('resources')
      .join('users', 'resources.author_id', 'users.id')
      .where('resources.id', id)
      .where('resources.is_public', true)
      .select(
        'resources.*',
        'users.full_name as author_name'
      )
      .first();

    if (!resource) {
      res.status(404).json({
        success: false,
        error: 'Resource not found',
        timestamp: new Date().toISOString()
      });
      return;
    }

    const resourceResponse = {
      id: resource.id,
      title: resource.title,
      description: resource.description,
      content: resource.content,
      category: resource.category,
      authorId: resource.author_id,
      authorName: resource.author_name,
      tags: JSON.parse(resource.tags || '[]'),
      isPublic: resource.is_public,
      downloadUrl: resource.download_url,
      fileType: resource.file_type,
      createdAt: resource.created_at,
      updatedAt: resource.updated_at
    };

    res.json({
      success: true,
      data: resourceResponse,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    logger.error('Error getting resource:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to get resource',
      timestamp: new Date().toISOString()
    });
  }
});

// PUT /api/resources/:id - Update resource (author or admin only)
router.put('/:id', authenticate, createResourceValidation, async (req: AuthenticatedRequest, res: Response): Promise<void> => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      res.status(400).json({
        success: false,
        error: 'Validation failed',
        details: errors.array(),
        timestamp: new Date().toISOString()
      });
      return;
    }

    if (!req.user) {
      res.status(401).json({
        success: false,
        error: 'User not authenticated',
        timestamp: new Date().toISOString()
      });
      return;
    }

    const { id } = req.params;
    const { title, description, content, category, tags = [], isPublic = true }: ResourceCreate = req.body;
    const db = getDatabase();

    const resource = await db('resources').where({ id }).first();
    if (!resource) {
      res.status(404).json({
        success: false,
        error: 'Resource not found',
        timestamp: new Date().toISOString()
      });
      return;
    }

    // Check if user is the author or admin
    if (resource.author_id !== req.user.id && req.user.role !== UserRole.ADMIN) {
      res.status(403).json({
        success: false,
        error: 'Access denied',
        timestamp: new Date().toISOString()
      });
      return;
    }

    const updateData = {
      title,
      description: description || null,
      content,
      category,
      tags: JSON.stringify(tags),
      is_public: isPublic,
      updated_at: new Date().toISOString()
    };

    await db('resources').where({ id }).update(updateData);

    const updatedResource = await db('resources').where({ id }).first();
    
    const resourceResponse = {
      id: updatedResource.id,
      title: updatedResource.title,
      description: updatedResource.description,
      content: updatedResource.content,
      category: updatedResource.category,
      authorId: updatedResource.author_id,
      tags: JSON.parse(updatedResource.tags || '[]'),
      isPublic: updatedResource.is_public,
      downloadUrl: updatedResource.download_url,
      fileType: updatedResource.file_type,
      createdAt: updatedResource.created_at,
      updatedAt: updatedResource.updated_at
    };

    logger.info(`Resource updated: ${id} by user ${req.user.email}`);
    res.json({
      success: true,
      data: resourceResponse,
      message: 'Resource updated successfully',
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    logger.error('Error updating resource:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to update resource',
      timestamp: new Date().toISOString()
    });
  }
});

// DELETE /api/resources/:id - Delete resource (author or admin only)
router.delete('/:id', authenticate, async (req: AuthenticatedRequest, res: Response): Promise<void> => {
  try {
    if (!req.user) {
      res.status(401).json({
        success: false,
        error: 'User not authenticated',
        timestamp: new Date().toISOString()
      });
      return;
    }

    const { id } = req.params;
    const db = getDatabase();

    const resource = await db('resources').where({ id }).first();
    if (!resource) {
      res.status(404).json({
        success: false,
        error: 'Resource not found',
        timestamp: new Date().toISOString()
      });
      return;
    }

    // Check if user is the author or admin
    if (resource.author_id !== req.user.id && req.user.role !== UserRole.ADMIN) {
      res.status(403).json({
        success: false,
        error: 'Access denied',
        timestamp: new Date().toISOString()
      });
      return;
    }

    await db('resources').where({ id }).delete();

    logger.info(`Resource deleted: ${id} by user ${req.user.email}`);
    res.json({
      success: true,
      message: 'Resource deleted successfully',
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    logger.error('Error deleting resource:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to delete resource',
      timestamp: new Date().toISOString()
    });
  }
});

export default router;
