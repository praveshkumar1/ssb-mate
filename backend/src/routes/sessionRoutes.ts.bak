import { Router, Request, Response } from 'express';
import { body, validationResult } from 'express-validator';
import { v4 as uuidv4 } from 'uuid';
import { getDatabase } from '../database/connection';
import { logger } from '../utils/logger';
import { authenticate, AuthenticatedRequest } from '../middleware/auth';
import { SessionCreate, SessionUpdate, SessionType, SessionStatus, UserRole } from '../types/enhanced';

const router = Router();

// Validation rules
const createSessionValidation = [
  body('mentorId').isUUID().withMessage('Invalid mentor ID'),
  body('title').trim().isLength({ min: 3 }).withMessage('Title must be at least 3 characters'),
  body('description').optional().isLength({ max: 500 }).withMessage('Description must be less than 500 characters'),
  body('sessionType').isIn(Object.values(SessionType)).withMessage('Invalid session type'),
  body('scheduledAt').isISO8601().withMessage('Invalid date format'),
  body('durationMinutes').optional().isInt({ min: 15, max: 240 }).withMessage('Duration must be between 15 and 240 minutes')
];

const updateSessionValidation = [
  body('notes').optional().isLength({ max: 1000 }).withMessage('Notes must be less than 1000 characters'),
  body('rating').optional().isInt({ min: 1, max: 5 }).withMessage('Rating must be between 1 and 5'),
  body('feedback').optional().isLength({ max: 1000 }).withMessage('Feedback must be less than 1000 characters'),
  body('status').optional().isIn(Object.values(SessionStatus)).withMessage('Invalid status'),
  body('meetingLink').optional().isURL().withMessage('Invalid meeting link')
];

// POST /api/sessions - Create a new session
router.post('/', authenticate, createSessionValidation, async (req: AuthenticatedRequest, res: Response): Promise<void> => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      res.status(400).json({
        success: false,
        error: 'Validation failed',
        details: errors.array(),
        timestamp: new Date().toISOString()
      });
      return;
    }

    if (!req.user) {
      res.status(401).json({
        success: false,
        error: 'User not authenticated',
        timestamp: new Date().toISOString()
      });
      return;
    }

    const { mentorId, title, description, sessionType, scheduledAt, durationMinutes = 60 }: SessionCreate = req.body;
    const db = getDatabase();

    // Verify mentor exists and is a mentor
    const mentor = await db('users').where({ id: mentorId, role: UserRole.MENTOR, is_active: true }).first();
    if (!mentor) {
      res.status(404).json({
        success: false,
        error: 'Mentor not found or inactive',
        timestamp: new Date().toISOString()
      });
      return;
    }

    // Create session
    const sessionId = uuidv4();
    const now = new Date().toISOString();

    const sessionData = {
      id: sessionId,
      mentor_id: mentorId,
      mentee_id: req.user.id,
      title,
      description: description || null,
      session_type: sessionType,
      scheduled_at: scheduledAt,
      duration_minutes: durationMinutes,
      status: SessionStatus.SCHEDULED,
      created_at: now,
      updated_at: now
    };

    await db('sessions').insert(sessionData);

    const session = {
      id: sessionId,
      mentorId,
      menteeId: req.user.id,
      title,
      description,
      sessionType,
      scheduledAt,
      durationMinutes,
      status: SessionStatus.SCHEDULED,
      createdAt: now,
      updatedAt: now
    };

    logger.info(`Session created: ${sessionId} by user ${req.user.email}`);
    res.status(201).json({
      success: true,
      data: session,
      message: 'Session created successfully',
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    logger.error('Error creating session:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to create session',
      timestamp: new Date().toISOString()
    });
  }
});

// GET /api/sessions - Get user sessions
router.get('/', authenticate, async (req: AuthenticatedRequest, res: Response): Promise<void> => {
  try {
    if (!req.user) {
      res.status(401).json({
        success: false,
        error: 'User not authenticated',
        timestamp: new Date().toISOString()
      });
      return;
    }

    const { page = 1, limit = 10, status } = req.query;
    const db = getDatabase();
    const offset = (Number(page) - 1) * Number(limit);

    let query = db('sessions')
      .where(function() {
        this.where('mentor_id', req.user!.id).orWhere('mentee_id', req.user!.id);
      });

    if (status) {
      query = query.where('status', status);
    }

    const sessions = await query
      .select('*')
      .limit(Number(limit))
      .offset(offset)
      .orderBy('scheduled_at', 'desc');

    const totalCount = await db('sessions')
      .where(function() {
        this.where('mentor_id', req.user!.id).orWhere('mentee_id', req.user!.id);
      })
      .count('* as count')
      .first();

    const total = Number(totalCount?.count || 0);
    const totalPages = Math.ceil(total / Number(limit));

    const sessionResponse = sessions.map(session => ({
      id: session.id,
      mentorId: session.mentor_id,
      menteeId: session.mentee_id,
      title: session.title,
      description: session.description,
      sessionType: session.session_type,
      scheduledAt: session.scheduled_at,
      durationMinutes: session.duration_minutes,
      status: session.status,
      meetingLink: session.meeting_link,
      notes: session.notes,
      rating: session.rating,
      feedback: session.feedback,
      createdAt: session.created_at,
      updatedAt: session.updated_at
    }));

    res.json({
      success: true,
      data: sessionResponse,
      pagination: {
        page: Number(page),
        limit: Number(limit),
        total,
        totalPages,
        hasNext: Number(page) < totalPages,
        hasPrevious: Number(page) > 1
      },
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    logger.error('Error getting sessions:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to get sessions',
      timestamp: new Date().toISOString()
    });
  }
});

// GET /api/sessions/:id - Get session by ID
router.get('/:id', authenticate, async (req: AuthenticatedRequest, res: Response): Promise<void> => {
  try {
    if (!req.user) {
      res.status(401).json({
        success: false,
        error: 'User not authenticated',
        timestamp: new Date().toISOString()
      });
      return;
    }

    const { id } = req.params;
    const db = getDatabase();

    const session = await db('sessions').where({ id }).first();
    if (!session) {
      res.status(404).json({
        success: false,
        error: 'Session not found',
        timestamp: new Date().toISOString()
      });
      return;
    }

    // Check if user is part of this session
    if (session.mentor_id !== req.user.id && session.mentee_id !== req.user.id) {
      res.status(403).json({
        success: false,
        error: 'Access denied',
        timestamp: new Date().toISOString()
      });
      return;
    }

    const sessionResponse = {
      id: session.id,
      mentorId: session.mentor_id,
      menteeId: session.mentee_id,
      title: session.title,
      description: session.description,
      sessionType: session.session_type,
      scheduledAt: session.scheduled_at,
      durationMinutes: session.duration_minutes,
      status: session.status,
      meetingLink: session.meeting_link,
      notes: session.notes,
      rating: session.rating,
      feedback: session.feedback,
      createdAt: session.created_at,
      updatedAt: session.updated_at
    };

    res.json({
      success: true,
      data: sessionResponse,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    logger.error('Error getting session:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to get session',
      timestamp: new Date().toISOString()
    });
  }
});

// PUT /api/sessions/:id - Update session
router.put('/:id', authenticate, updateSessionValidation, async (req: AuthenticatedRequest, res: Response): Promise<void> => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      res.status(400).json({
        success: false,
        error: 'Validation failed',
        details: errors.array(),
        timestamp: new Date().toISOString()
      });
      return;
    }

    if (!req.user) {
      res.status(401).json({
        success: false,
        error: 'User not authenticated',
        timestamp: new Date().toISOString()
      });
      return;
    }

    const { id } = req.params;
    const updateData: SessionUpdate = req.body;
    const db = getDatabase();

    const session = await db('sessions').where({ id }).first();
    if (!session) {
      res.status(404).json({
        success: false,
        error: 'Session not found',
        timestamp: new Date().toISOString()
      });
      return;
    }

    // Check if user is part of this session
    if (session.mentor_id !== req.user.id && session.mentee_id !== req.user.id) {
      res.status(403).json({
        success: false,
        error: 'Access denied',
        timestamp: new Date().toISOString()
      });
      return;
    }

    // Prepare update object
    const dbUpdateData: any = {
      updated_at: new Date().toISOString()
    };

    if (updateData.notes !== undefined) dbUpdateData.notes = updateData.notes;
    if (updateData.rating !== undefined) dbUpdateData.rating = updateData.rating;
    if (updateData.feedback !== undefined) dbUpdateData.feedback = updateData.feedback;
    if (updateData.status !== undefined) dbUpdateData.status = updateData.status;
    if (updateData.meetingLink !== undefined) dbUpdateData.meeting_link = updateData.meetingLink;

    await db('sessions').where({ id }).update(dbUpdateData);

    // Get updated session
    const updatedSession = await db('sessions').where({ id }).first();
    
    const sessionResponse = {
      id: updatedSession.id,
      mentorId: updatedSession.mentor_id,
      menteeId: updatedSession.mentee_id,
      title: updatedSession.title,
      description: updatedSession.description,
      sessionType: updatedSession.session_type,
      scheduledAt: updatedSession.scheduled_at,
      durationMinutes: updatedSession.duration_minutes,
      status: updatedSession.status,
      meetingLink: updatedSession.meeting_link,
      notes: updatedSession.notes,
      rating: updatedSession.rating,
      feedback: updatedSession.feedback,
      createdAt: updatedSession.created_at,
      updatedAt: updatedSession.updated_at
    };

    logger.info(`Session updated: ${id} by user ${req.user.email}`);
    res.json({
      success: true,
      data: sessionResponse,
      message: 'Session updated successfully',
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    logger.error('Error updating session:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to update session',
      timestamp: new Date().toISOString()
    });
  }
});

export default router;
